For this project, you will be working on a web client and two Solidity contracts to implement a decentralized cryptocurrency exchange. By the end of the project, your exchange will have much of the functionality possessed by full fledged decentralized exchanges such as Uniswap. Additionally, you will create your own ERC20 token, which you will then trade over your exchange.
Throughout this project, make sure to write code that is resilient against adversarial attacks. Remember that attackers can call your smart contracts with arbitrary inputs, not just through the provided user interface. As such, make liberal use of require statements to test any assumptions baked into your code.
For most students, this project will likely represent their most comprehensive project imple- mented so far in Solidity. As such, we encourage you to start early and ask questions. We will guide you through implementing a decentralized exchange in several phases, and we believe your end product will give you something to be very proud of! Let’s get started.
As part of this, we will also build a user interface that computes useful information for the user and allows non-programmers to use the DApp.

1	Getting Started
1.1	Setup
1.	Install the prerequisite software: you’ll need to download and install Node.js. Hardhat only supports Node.js V12.xx, 14.xx, and 16.xx. You can find the previous releases here, and select an appropriate version to install.
2.	Download and extract the starter code from the course website.
3.	cd into the starter code directory.
4.	Run npm install --save-dev hardhat to install the Ethereum development environment Hardhat, which you will use to simulate an Ethereum node on your local machine. If you encounter an error in regards to an incompatible Node version, please install a supported Node.js version and use nvm use <version> to switch to it.
5.	Run npm install --save-dev @nomiclabs/hardhat-ethers ethers to install a Hardhat plugin to deploy a Hardhat node which your scripts will use.
6.	Run npm install --save-dev @openzeppelin/contracts to install OpenZeppelin libraries.
 
1.2	Compile, Deploy and Test
1.	You’ll be modifying contracts/token.sol and contracts/exchange.sol to define your Solidity contracts and web_app/exchange.js to build the Javascript backend. Looking at the other files may help understand how the Hardhat node and web client works. There are places marked with functions to modify and you can add helper functions to the three files listed above. Please do not modify any other code or install additional node packages.
2.	Peruse the starter code, the ethers.js documentation, the Solidity documentation, and the OpenZeppelin ERC-20 contract implementation. Think carefully about the overall design of your system before you write code. What data should be stored on chain? What computation will be done by the contract vs. on the client?
3.	After you finish implementation, run npx hardhat node to start the local node. If the node is started correctly, you should see in terminal: Started HTTP and WebSocket JSON-RPC server at https://localhost:8545
4.	Deploying the Contracts: Open another terminal tab or window, and cd into the starter code directory.
Run npx hardhat run --network localhost scripts/deploy_token.js to compile and deploy your token contract. Upon success, you should see this message on the terminal: Successfully wrote token address <token address> to token address.txt. Copy that value and paste it into the address tokenAddr field in contracts/exchange.sol. Alterna- tively copy it from token address.txt in your proj4 directory.
5.	Run npx hardhat run --network localhost scripts/deploy_exchange.js to deploy your exchange contract.	Upon success, you should see Successfully wrote token address
<exchange address> to exchange address.txt. Save that value value for the next step. Alternatively copy it from exchange address.txt in your proj4 directory.
Step 5 is the same as Step 4 but instead for the contract exchange.sol. The newly created contract address will be copied in Step 6.
6.	Update the contract address and ABI in web_app/exchange.js.
Update the const token_address and const exchange_address variables with the two con- tract addresses. Unlike in Solidity, the addresses in Javascript do not need to be checksummed.

The ABIs can be copied from artifacts/contracts/token.sol/token.json and artifacts/contracts/exchange.sol/exchange.json. To correctly update the ABI, please copy the whole list after the ‘abi’ field, starting from the square bracket. The address is saved in the previous step. Make sure your contract address is a string.
7.	Open the web_app/index.html file in your browser. Until you have finished implementing Section 3 (contracts/token.sol), there will be an error in the browser console. Otherwise, you can play around with the page, and run sanityCheck! See Section 10 for more details.
Note on OSs: All of the above steps should work on Unix-based systems and Windows. The commands we ask you to execute will work in a standard Unix terminal and the Windows Command Prompt.
 
2	Components
The project has three major components:
•	contracts/token.sol is a smart contract written in Solidity that will be deployed on the blockchain. You will have to modify it to create and deploy your own token. See Section 3 for implementation details.
•	contracts/exchange.sol is another smart contract written in Solidity that will be deployed on the blockchain. You will have to modify it to create and deploy a decentralized exchange (DEX), also called an automated market maker (AMM), modeled after Uniswap V1. See Section 4 for implementation details.
•	web app/exchange.js is a client running locally in a web browser written in JavaScript. It observes the blockchain using the ethers.js library and can calls functions in the smart contracts token.sol and exchange.sol. See Section 4 for more details. For more information on how ethers.js works and setting up this assignment, watch the Section 5 recording on Panopto.
Also, file web app/index.html when opened in your browser (works best in Chrome) allows you to access the user interface through which you can test your exchange. On this page, you can pick an address and add liquidity, remove liquidity, and swap your token for ETH and vice-versa. This file and other files should not be modified. Only token.sol, exchange.sol and exchange.js should be modified.

3	Create and Deploy Your Own Token
In the first part of this project, you will create and deploy your own ERC-20 token. ERC-20, as mentioned in class, is a standard for implementing fungible tokens. Luckily for us, much of the code for ERC-20 standard has already been written and is open source. In this project, we will use the standard ERC-20 implementation from the OpenZeppelin project. Make sure you understand the ERC-20 standard, as well as the OpenZeppelin implementations of ERC-20 and Ownable.
Once you’ve read through the starter code, complete the following steps in contracts/token.sol and web_app/exchange.js:
1.	Come up with a fun (but appropriate!) name for your token. Set the private string _name of token.sol to be the name of your token. In addition, update the token_name variable at the top of exchange.js to be the same name.
2.	Decide on a short symbol for your token (e.g. ETH, instead of Ethereum). Set the private string _symbol to be that symbol, and update the token symbol variable at the top of exchange.js with the same name.
3.	Implement minting functionality in the token contract. You will primarily do this with mint(uint amount) and disable mint() functions but you may add to the contract how- ever you choose. mint is a public function that creates amount tokens. You can do this by using the inherited OpenZeppelin ERC-20 contract function mint(address, uint256). disable mint() makes it such that calling mint() will never succeed again. As such, your
 
mint implementation must fail if disable mint() has been called. Also note the Ownable modifier on both functions, which makes it such that only the contract administrator can call either one.
4.	Deploy your token contract. Copy the address and ABI of the token contract to the token address
and token abi variables in exchange.js.
5.	Lastly, copy the address of the token contract to the tokenAddr variable in exchange.sol. Remember to use the checksummed version of the address in the contract. Every time you redeploy your token contract, you must repeat this step.
After completing the above steps, you should have your own token all deployed on Hardhat!

Follow the steps 3-7 as in section 1.2 once again and you should now have a working token! All the functionality except initial pool setup (which we implemented for you) will be missing. That said, if you have completed Section 2 and the deployment process properly, you should see no errors occur in your browser console and should see a 1-to-1 exchange rate between ETH and your token. There should be 5000 ETH and 5000 of your tokens in under the ”Current Liquidity” display.

4	Setting Up Your Basic Exchange
In this part of the assignment, you will implement the basic functionality of your cryptocurrency exchange. Our exchange is modeled after Uniswap V1. Your exchange will only allow for swaps between your Token and test ETH. The changes in this section will primarily affect two files: exchange.js and exchange.sol. Familiarize yourself with the starter code for those files.
A decentralized exchange consists of two types of participants: traders and liquidity providers (LP).

4.1	Trading/Swapping
When traders swap between the two currencies, they will add some amount of one currency to the liquidity pool, and will be sent an equal value of the other currency from the pool. The exchange rate between the two currencies is determined by the constant product formula:
Let x be the amount of currency A that is in the liquidity pool, and let y be the amount of currency B. Let k be some constant. After every swap, it must be true that
x ∗ y = k.

During each swap, the exchange must send out the correct amount of the swapped-to currency such that this formula holds. The price of currency B in terms of currency A can the be calculated as x/y, whereas the price of currency A in terms of currency B can be calculated as y/x. Every swap will thus modify the exchange rate. This makes sense, as each swap is an indication of demand for a given currency.
 
4.2	Adding and Removing Liquidity
When a liquidity provider adds/removes liquidity, they must provide/withdraw equal values of currency A(∆x) and B(∆y), as determined by the current exchange rate.
xcur = xcur + ∆x = xnew
 
ycur
 
ycur + ∆y
 
ynew
 
This will result in a change in the value of k which is the product of the reserves of each token:
knew = xnew ∗ ynew = (xcur + ∆x) ∗ (ycur + ∆y)
This has another notable consequence: since a liquidity provider can only withdraw equal values of each currency, they are not actually entitled to withdraw their exact initial investment (in terms of quantity of each token). Rather, providing liquidity is analagous to owning a percentage share of the liquidity pool, which the provider is then entitled to withdraw at a later time. A liquidity provider who provided 10% currency A and currency B is entitled to withdraw 10% of each of the reserves for those currencies. Note that your percentage share depends on the behaviour of other LPs. For example if another LP adds liquidity your percentage share decreases.

4.3	Basic Implementation
With the above in mind, you will now implement the basic functionality of your exchange. We take care of initializing the pool for you by implementing and calling the createPool function. We take ETH and tokens from the first address to initialize the pool, and you do not need to track this initial amount when tracking liquidity providers. In order for other addresses to obtain tokens and/or provide liquidity, they must first swap for tokens on the exchange. In exchange.sol, implement the following functions:
•	function addLiquidity() external payable:
Add liquidity to the pool if the provider possesses sufficient ETH and tokens (otherwise the transaction should fail). The caller will send ETH to the contract, which can be accessed using msg.value. This function should also transfer the equivalent amount of tokens based on the current exchange rate from the sender’s address to the contract (using the token’s transfer or transferFrom method), and update the exchange state accordingly. The transaction must fail if the provider’s funds are insufficient. See Section 9 for advice on how to best keep track of liquidity.
•	function removeLiquidity(uint amountETH) public payable:
Remove a specified amount of liquidity from the pool (if the provider is entitled to remove given amount of liquidity) and update the exchange state accordingly. amountETH is numeric amount of ETH the liquidity provider wants to take out, so they should receive a total value equivalent to 2 * amountETH after they receive tokens and ETH. Be sure to update the amount of liquidity provided by each liquidity provider accordingly. The function should fail if users try to remove more liquidity than they are entitled to, or if they try to deplete the ETH or token reserves to 0.
•	function removeAllLiquidity() external payable:
Remove the maximum amount of liquidity that the sender is allowed to remove and update the
 
exchange state accordingly. In addition, be sure to update the amount of liquidity provided by each liquidity provider. Similarly, this function should fail if the liquidity provider will drain the ETH or token reserves to 0.
•	function swapTokensForETH(uint amountTokens) external payable:
Swap the given amount of tokens for the equivalent value of ETH and update the exchange state accordingly. If the provider does not have sufficient tokens for the swap, the transaction should fail. Additionally, if completing the swap would completely remove all ETH from the pool, the transaction should fail to avoid having zero ETH and (therefore) an undefined exchange rate. Be sure to leave at least 1 ETH and 1 token in the pool at all times.
•	function swapETHForTokens() external payable:
Swap the given amount of ETH for the equivalent value in your token and update the exchange state accordingly. Similar to addLiquidity(), the sender would send ETH into the contract, which can be accessed through msg.value. If completing the swap would completely remove all tokens from the pool, the transaction should fail to avoid having zero tokens and (therefore) an undefined exchange rate. Be sure to leave at least 1 ETH and 1 token in the pool at all times.
In each of the above functions, be sure that you are adjusting token reserves, eth reserves, and/or k in the correct way such that the exchange is always on the constant product curve de- scribed above. Additionally, be sure that functions fail when the caller does not possess sufficient funds. Finally, remember to set address tokenAddr to be your deployed token contract’s address. You can now run npx hardhat run --network localhost scripts/deploy exchange.js to de- bug and deploy your code.

Round-off errors. When a swap happens round off errors can occur meaning that product eth reserves * token reserves is not strictly equal to k. You should attempt to minimize these round-off errors (discussed in Section 9), however it is ok if eth reserves * token reserves deviates slightly from k. The only times that you need to update k is when adding or removing liquidity.


5	Implementing the Backend
After you finish implementing the contract functions, implement the following functions in exchange.js. You can ignore the maxSlippagePct variable for now – this will be used in Section 6. For the most part, these would just call the token and exchange functions you wrote above:
•	async function addLiquidity(amountEth, maxSlippagePct)
•	async function removeLiquidity(amountEth, maxSlippagePct)
•	async function removeAllLiquidity(maxSlippagePct)
•	async function swapTokensForETH(amountToken, maxSlippagePct)
•	async function swapETHForTokens(amountEth, maxSlippagePct)
 
Approving token transfers. In order for a third-party address (for example, the contract) to send tokens on your behalf, you must first grant them permission to by using the token contract’s approve() function. This function would need to be initiated by the user, you will not be able to run approve() from the contract itself. Thus, be sure to call this function in the Javascript before calling the exchange function when appropriate. The details of this function can be found in Openzeppelin’s ERC20 implementation.

You  can  call  contract  code  with  await   contract.connect(anotherSigner).functionName(args).
For more syntax help, we strongly encourage you to check out the ethers.js documentation, as well as Section 9 for some tips.
Once you’ve fully implemented your smart contract and the corresponding JavaScript code, update the token abi and exchange abi variables at the top of the file, and copy the contract addresses to the token address and exchange address variables in exchange.js. Be sure to include the outermost brackets when copying the ABI. If you reload index.html, you should now be able to provide liquidity, remove liquidity, and perform swaps.

6	Handling Slippage
There is a significant issue with our exchange as we implemented it in Section 3, as it does not account for ”slippage”. Recall that with every swap on a decentralized exchange, the exchange rate will shift. Since many users may be trying to swap currency at once on a decentralized exchange, there may be a shift in the exchange rate between the submission of a swap transaction and the actual processing of that transaction. Another cause of slippage is when the slippage when your trade is large relative to the size of the liquidity pool. This would mean that the amount of currency you receive back is far lower so that k is maintined. Any shift in the exchange rate between the exchange’s quote price and actual price is called ”slippage.” Slippage is of particular concern while trading volatile assets. For traders, if a user submits a swap transaction to swap some amount of currency A for currency B, and then the price of currency B dramatically increases from the quote price, the user might not actually wish to complete the swap transaction. For LPs slippage is bad because it can results in impermanent loss.
The most common way to deal with slippage is to allow users to set some maximum slippage while submitting the transaction. This parameter, typically a percentage, will cause the transaction to fail if the price of the assets has changed by more than the maximum allowed slippage. To implement a maximum slippage requirement, perform the following steps:
1.	In exchange.sol, update your swapTokensForETH and swapETHForTokens functions to take in a uint max exchange rate parameter. You may also pass in additional or different pa- rameters if needed for your design. While swapping, the swap should fail if the current price of the new asset (i.e. the asset the user is swapping to) has increased to more than the max- imum exchange rate. Note that the price of the asset decreasing is good for the user, so we don’t have to fail in that case. See section 9 for advice on how to handle underflow issues with the exchange rates. For example if trading 100 ETH and expect 100 Tokens with 5% slippage, the contract should reject any situation where the trader would receive fewer than 95 Tokens.
2.	Update addLiquidity, removeLiquidity, and removeAllLiquidity functions to take in
 
uint max exchange rate and uint min exchange rate parameters. Similarly, you may pass in other parameters if needed for your design. While providing liquidity, the transaction should fail if the exchange rate has changed significantly i.e. increased to more than the maximum exchange rate or fallen below the minimum exchange rate. This is because exchange rate shifts in either direction can subject providers to impermanent loss before they deposit their liquidity. Again see section 9 for advice on how to handle underflow issues with the exchange rates.
3.	Now update your exchange.js file to communicate with the contract about the max/min exchange rates. The maxSlippagePct parameter is provided, which represents the maximum allowable percent price change before the transaction should fail. In testing and in the browser interface, this parameter is passed as an int, not as a float - i.e. 4% is passed as 4, not 0.04. This parameter can be used in each of the JavaScript functions to calculate the correct values for max exchange rate and/or min exchange rate, which can then be passed to the contract. The getPoolState function that we provide to you may be useful here.
As always, after updating your contract make sure to recompile, redeploy, and copy the new ABI and contract address to the variable at the top of your exchange.js file. At this point, you can also uncomment the sanityCheck() function to check your implementation. See Section 10 for more details about the sanityCheck.

7	Rewarding Liquidity Providers
After completing the above sections, you now have a working exchange that allows users to limit the amount of slippage they wish to tolerate! There is one more big issue, however. We have discussed several times how liquidity providers are taking on risk in the form of impermanent loss. That is, the value of their liquidity stake may decrease if the price of either asset changes. In practice, since many cryptocurrencies are quite volatile, this is a level of risk that no liquidity provider would be willing to take on for free.
As such, we need to incentivize liquidity providers to give liquidity to the pool. In real world exchanges, liquidity providers are incentivized to provide liquidity because they receive a small fee from every swap transaction. For the basic implementation in this assignment, these fees are stored in separate rewards pools on behalf of each liquidity provider (eth fee reserves and token fee reserves). When a provider goes to withdraw their liquidity and are removing fraction f of total liquidity, they should receive fraction f of all the rewards. Ordinarily what ought to be returned to lps when they remove liquidity is the all of rewards awarded to them since they entered the liquidity pool. You do not need to do this for full credit but extra credit will be awarded for this implementation as described in Section 7.1.
You will now implement the same fee reward scheme for liquidity providers. You are free to design your own as long as it meets the requirements stated at the end of this section. However, we strongly suggest the following one, explained in plain text.
•	Each liquidity provider has ownership of a fraction f of the mining pool. This fraction is stored in the smart contract for each liquidity provider (ie. the lps mapping stores the number of shares for each address). For this assignment, we’ll be setting the swap fee to 3% to aid with the autograder, as represented by the swap fee numerator and swap fee denominator
 
fields. The liquidity providers’ ownership proportions should be unchanged when swaps are performed, since liquidity rewards are distributed based on each lp’s ownership percentages.
•	When a liquidity provider withdraws its liquidity, they get a fraction f of both tokens in the pool corresponding to their ownership fraction, as well as their rewards. Other liquidity providers have their ownership fraction increased accordingly. All the fractions should add up to 1.
•	When a liquidity provider adds liquidity in the pool, they get an ownership fraction f on the pool equal to the proportion of their tokens in the new state of the pool. The implementation of this is detailed in Section 9.
If you have implemented liquidity tracking with fractions, then this section should not take too much additional work. Alternatively, we will also accept any design that fulfills the requirements listed below.

Liquidity Rewards Requirements:
1.	Your pool must charge the person performing the swap a percentage fee for every swap transaction.1 This percentage is defined for you with private variables swap fee numerator and swap fee denominator, as explained above.
2.	The fee must be taken from only the currency being traded in.
3.	The fee that is taken out should not influence the exchange rate of your DEX. This means that the value of currency being sent to the trader should correspond to the (amount traded in) - (fee taken out). As an example is 100 ETH is traded in with swap percentage fee p, p ∗ 100 ETH is taken as fee and the trader should be given (1 − p) ∗ 100 worth of tokens.
4.	Basic: When removing fraction f of the liquidity pools total liquidity, lps should receive fraction f of all current token fees and all current ETH fees. This is not the case for extra credit implementation as described below.
5.	Liquidity providers should not have to take any additional steps to claim their fees beyond calling removeLiquidity. Additionally, liquidity rewards should not be sent out of the exchange to the providers each time a swap takes place, since doing so would be prohibitively expensive in practice.
6.	We will not grade for gas for this part of the assignment, but we encourage you to opt for a solution that minimizes gas costs
After designing and implementing the above section, you should have a fully working exchange! Congratulations! Test your functions using the provided UI in index.html, or write testing code in JavaScript. Implementing this project represents a very impressive achievement, so give yourself a pat on the back. In fact, with some security modifications, you can deploy both your token and your exchange onto the Ethereum mainnet, and thus have an exchange you can call your own!

1For reference, the default fee on Uniswap is 0.3%, whereas centralized exchanges typically charge around 1-4% to swap currencies.
 
7.1	Extra Credit
Ordinarily when a fee is taken during a swap, the fee is distributed to the liquidity providers based on their fraction of lp ownership at the time the swap took place. Then whenever an lp removes liquidity, they should receive all the fees that have been distributed to them since they last removed liquidity (or since they entered the pool if they have not removed any liquidity yet). This is different from the basic implementation where they receive the fraction of fees corresponding to the fraction of ownership they are removing. This basic implementation is incorrect because it allows lps to take rewards earned before they entered the pool.
For extra credit, you may chose to correctly implement rewards lps as described above. This means that when lps remove liquidity the fees they receive are based only on swaps that occured while they were liquidity providers. Note that you still should not be sending out liquidity rewards at the time a swap takes place.

8	Note on Solidity and Javascript Decimals
Unlike most programming languages, Solidity does not support floating point arithmetic. To avoid this ether represents ethereum in units of 10−18 ETH or 1 WEI. For example, 1 ETH would be represented as 1018 in the contract. Similarly, 1 wei = 10−18 ETH, so 1 wei is represented as just
1. Indeed, our contracts expect the msg.value field to be in WEI. Unfortunately, Javascript also has a limit to how large integers can be: Numbers.MAX INT = 9 ∗ 1015.
To deal with this we use the ethers.utils library to do conversions for us. To convert a value
in ETH to the value that solidity wants use the ethers.utils.parseEther(string amountEth) function. This will return the BigInt representation of the amount of WEI that is equivalent to amountEth ETH. This can in turn be passed in as the msg.value to contract calls. For an example of this, look at when the contract function createPool is called in the init function in exchange.js.

9	Implementation Advice
While the overall design of your contract is open-ended, here is some advice that you should take to streamline your implementation process:
1.	To help debugging you can used the hardhat/console.sol package to print out information you wish to in the window that you are running the command npx hardhat node on. Details on how to use this package can be found here.
2.	Keep track of the liquidity providers’ proportions, rather than absolute values. For example, if there is 1000 ETH and 1000 tokens in the pool, and Alice provides 500 ETH and 500 tokens, then Alice is entitled to 500/(500+1000) = 1/3 of the pool. The best way to represent this is through storing the number of shares that each LP has. The pool is initialized to have 105 shares and whenever liquidity is added or removed the total shares should increase and decrease respectively. In the example above, the total shares would increase to 1.5 × 105 and Alice would have 5 × 104 shares (1/3 of the pool). During swaps, this share values should not change (even when implementing lp rewards).
 
3.	Handing edge rounding errors. Again, since Solidity does not support floating points, we recommend you to perform multiplication before division whenever possible. This avoids running into division rounding to 0, and then multiplying to get 0 again. Similarly, with uint types, be sure to perform addition before subtraction when possible to prevent underflow.
4.	Using Min/Max Exchange Rates In Section 6 you are asked to deal with slippage. The suggested implementation involves passing in the exchange rate. However, this value is most likely a floating point value very close to 1 meaning that it will be subject to under- flow. To avoid this issue do all comparisons of exchange rates after multiplying the rates provided multipliers (const exchange rate multiplier in exchange.js and the multiplier in exchange.sol). As an example if the exchange rate is 1 and your slippage is 10%, the min and max exchange rates are 0.9, 1.1. Pass 0.9 ∗ 105, 1.1 ∗ 105 to the solidity contracts and compare accordingly to the current exchange rate ∗105.
5.	Sending ETH to and from the Contract. In order to successfully transfer ETH from a user account to a contract, the function that handles the transfer must be marked as payable. It is important to note that simply specifying an argument in the contract function to specify an amount of ETH will not transfer the ETH; rather, ETH is transferred via the msg.value parameter. In order to avoid simplify your implementation, please use ethers.utils.parseEther(string amountEther) when passing in ETH into the contract. Similarly, if you want to send ETH from the contract to the user address, then you can use the payable() function appropriately. More details can be found here.
6.	Accessing the contract address. You can get the contract’s address in Solidity by calling
address(this).
7.	Access the contract’s token and ETH amounts. While you can calculate your contract’s token and ETH amounts by hand while performing intermediate calculations, you can access the true balances with the following functions:
•	ETH balance: address(this).balance
•	Token   balance:   token.balanceOf(address(this))
Note that when implementing fees these values will include fees!
8.	Javascript Async Functions. It is important to note that all Solidity function calls will be async from the backend. Thus, in exchange.js, in order to call a function from the contract and get the output, be sure to use the await keyword, such as var num = await token  contract.function(args).
9.	Security of the Contract. Remember, since all deployed contracts are public on the chain, it is important to keep your contract safe. While we will not be actively testing your contract for security, we still expect to see some defenses via using require() or assert() statements.
10.	Extra Credit: Iterating through mapping keys. Solidity does not support iterating through keys of a mapping. Thus, we define address[] private lp providers for you to store the addresses of liquidity providers. In addition, remember that Solidity arrays do not automatically ”shift” all elements when a value in the middle of the array is removed. Thus, we provide a helper function removeLP() that removes a liquidity provider from the array
 
while filling the ”gap”. This will update lp providers.length accordingly. Be careful when calling this function while you are iterating through the array, however, as it is risky to change the length of the array while iterating through it if you want to reach every element.

10	Sanity Check
In order to test your implementation, we have implemented two sanity check programs that run depending on whether you have implemented liquidity rewards. We check this value by reading the swap fee numerator value in exchange.sol: if that value is 0, then we assume you have not implemented swap fees and liquidity rewards.

To enable sanity check, uncomment the setTimeout() function with sanityCheck(), and re- fresh the page. We tried to design the sanityCheck to run properly even after the first load, so you do not need to redeploy the contracts and reset the pool state every time you want to run sanityCheck. However, due to rounding errors, there might be a point in which the sanityCheck passes when the exchange rate is 1:1 but not with your current exchange status. Your sanityCheck evaluates your implementation assuming the initial pool state is – the exchange rate between tokens is 1:1, and there are 5000 ETH and 5000 tokens in the pool.

These sanity checks are extremely approximate and do not indicate that your so- lution is correct if you pass them. Please do not reverse engineer the sanity checks to understand how you should be implementing your assignments as this will be mis- leading. Reach out to a course instructor with any questions.

11	Design Document
Please fill in DesignDoc.txt with your answers to the following questions:
1.	Explain why adding and removing liquidity to your exchange does not change the exchange rate.
2.	Explain your scheme for rewarding liquidity providers and justify the design decisions you made. How does it satisfy the liquidity rewards requirements outlined in Section 7?
3.	Describe at least one method you used to minimize your exchange contract’s gas usage. Why was this method effective?
4.	Optional Feedback
(a)	How much time did you spend on the assignment?
(b)	What is one thing that would have been useful to know before starting the assignment?
(c)	If you could change one with about this assignment, what would you change?
(d)	Please feel free to include any other feedback you may have.


